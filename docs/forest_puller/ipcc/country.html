<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>forest_puller.ipcc.country API documentation</title>
<meta name="description" content="Written by Lucas Sinclair and Paul Rougieux â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>forest_puller.ipcc.country</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair and Paul Rougieux.</p>
<p>JRC Biomass Project.
Unit D1 Bioeconomy.</p>
<p>Typically you can use this class like this:</p>
<pre><code>&gt;&gt;&gt; from forest_puller.ipcc.country import all_countries
&gt;&gt;&gt; for country in tqdm(all_countries): country.uncompress()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair and Paul Rougieux.

JRC Biomass Project.
Unit D1 Bioeconomy.

Typically you can use this class like this:

    &gt;&gt;&gt; from forest_puller.ipcc.country import all_countries
    &gt;&gt;&gt; for country in tqdm(all_countries): country.uncompress()
&#34;&#34;&#34;

# Built-in modules #
import re

# Internal modules #
from forest_puller.ipcc.year import Year
from forest_puller.ipcc.zip_files import all_zip_files
from forest_puller import cache_dir
from forest_puller.common import country_codes

# First party modules #
from plumbing.cache import property_cached

# Third party modules #
from tqdm import tqdm

###############################################################################
class Country:
    &#34;&#34;&#34;
    Represents one country&#39;s dataset and contains many `Year` objects.
    Each `Year` references a single excel file and has a `df` property.

    The final file structure will look like this:

        /puller_cache/ipcc/xls/AT:
            AUT_2019_1990_10042019_205508.xlsx
            AUT_2019_1991_10042019_205601.xlsx
            AUT_2019_1992_10042019_205654.xlsx
            AUT_2019_1993_10042019_205746.xlsx
            AUT_2019_1994_10042019_205839.xlsx
            ...

        /puller_cache/ipcc/xls/BE:
            BEL_2019_1990_12042019_023222.xlsx
            BEL_2019_1991_12042019_023341.xlsx
            BEL_2019_1992_12042019_023458.xlsx
            ...
    &#34;&#34;&#34;

    def __init__(self, iso2_code, xls_cache_dir):
        # The reference ISO2 code #
        self.iso2_code = iso2_code
        # Record where the cache will be located on disk #
        self.cache_dir = xls_cache_dir
        # Main directory #
        self.zip_dir = all_zip_files.cache_dir + self.iso2_code + &#39;/&#39;

    def __repr__(self):
        return &#39;%s object code &#34;%s&#34;&#39; % (self.__class__, self.iso2_code)

    # Convenience shortcut to self.all_years #
    def __getitem__(self, key): return self.all_years[key]
    def __iter__(self):         return iter(self.all_years)
    def __len__(self):          return len(self.all_years)

    # ---------------------------- Properties --------------------------------#
    @property_cached
    def iso3_code(self):
        &#34;&#34;&#34;Get the ISO3 code for this country.&#34;&#34;&#34;
        # Find the right row #
        row = country_codes.loc[country_codes[&#39;iso2_code&#39;] == self.iso2_code].iloc[0]
        # Get the ISO3 #
        return row[&#39;iso3_code&#39;]

    @property_cached
    def zip_files(self):
        &#34;&#34;&#34;Return a list of all zip files present for this country.&#34;&#34;&#34;
        return self.zip_dir.flat_files

    @property_cached
    def zip_file(self):
        &#34;&#34;&#34;
        Return only the single zip that we are interested in for this country.
        If there are several zip files available, we pick the one that matches
        the country&#39;s ISO3 code.
        For instance, in this study, we don&#39;t want to include large areas such
        as greenland when considering Denmark, nor French islands etc.
        &#34;&#34;&#34;
        # Standard case #
        if len(self.zip_files) == 0: return self.zip_files[0]
        # How to parse the ISO3 code from the filename #
        def find_iso3_code(zip_file):
            matches = re.findall(&#34;^([a-z]+)-[0-9]+&#34;, zip_file.name)
            if not matches: return None
            return matches[0]
        # Case with multiple choices #
        for z in self.zip_files:
            if find_iso3_code(z).upper() == self.iso3_code: return z

    @property_cached
    def xls_dir(self):
        &#34;&#34;&#34;Determine where to store all the xls files for this country.&#34;&#34;&#34;
        return self.cache_dir + self.iso2_code + &#39;/&#39;

    @property_cached
    def all_xls_files(self):
        &#34;&#34;&#34;For each country we have N excel files, one for each year.&#34;&#34;&#34;
        # If the xls_dir is empty, we need to reconstruct from cache #
        if self.cache_dir.empty:
            return [self.xls_dir + f.strip(&#39;\n&#39;) for f in self.cached_xls_list]
        # Otherwise we can just look at each file #
        return [f for f in self.xls_dir.flat_files if f.extension == &#39;.xlsx&#39;]

    @property_cached
    def all_years(self):
        &#34;&#34;&#34;Every file holds data for a specific year.&#34;&#34;&#34;
        return [Year(self, xls) for xls in self.all_xls_files]

    @property_cached
    def years(self):
        &#34;&#34;&#34;A dictionary of every year for which we have data.&#34;&#34;&#34;
        return {y.year: y for y in self.all_years}

    # ------------------------------ Convenience ---------------------------------#
    @property
    def first_year(self):
        &#34;&#34;&#34;The earliest year for which we have data.&#34;&#34;&#34;
        return self.all_years[0]

    @property
    def last_year(self):
        &#34;&#34;&#34;The latest year for which we have data.&#34;&#34;&#34;
        return self.all_years[-1]

    # ------------------------------ Methods ---------------------------------#
    def uncompress(self):
        &#34;&#34;&#34;Uncompress the zip file contents to its own directory.&#34;&#34;&#34;
        # Remove and regenerate #
        self.xls_dir.remove()
        self.zip_file.unzip_to(self.xls_dir, single=False)
        # Sometimes randomly the zip contains a directory so we have to unnest #
        all_dirs  = self.xls_dir.flat_directories
        all_files = self.xls_dir.flat_files
        if len(all_dirs) == 1 and len(all_files) == 0:
            nested_dir = all_dirs[0]
            nested_dir.unnest()
        # Return #
        return len(self.xls_dir)

    # ------------------------------- Caching ---------------------------------#
    @property
    def cached_xls_list(self):
        &#34;&#34;&#34;The location where we will save the list of excel files paths.&#34;&#34;&#34;
        return cache_dir + &#39;ipcc/countries/&#39; + self.iso2_code + &#39;.txt&#39;

    def write_xls_list(self):
        &#34;&#34;&#34;
        Create the file that will be used for caching the list of xls files.
        We have to record relative paths starting from self.xls_dir
        &#34;&#34;&#34;
        # Get all paths #
        paths = (f.rel_path_from(self.xls_dir) for f in self.all_xls_files)
        # Write to text file #
        self.cached_xls_list.writelines(line + &#39;\n&#39; for line in paths)
        # Return #
        return self.cached_xls_list

###############################################################################
# Create every country object #
cache_path    = cache_dir + &#39;ipcc/xls/&#39;
all_countries = [Country(iso2, cache_path) for iso2 in country_codes[&#39;iso2_code&#39;]]
countries     = {c.iso2_code: c for c in all_countries}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="forest_puller.ipcc.country.Country"><code class="flex name class">
<span>class <span class="ident">Country</span></span>
<span>(</span><span>iso2_code, xls_cache_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents one country's dataset and contains many <code>Year</code> objects.
Each <code>Year</code> references a single excel file and has a <code>df</code> property.</p>
<p>The final file structure will look like this:</p>
<pre><code>/puller_cache/ipcc/xls/AT:
    AUT_2019_1990_10042019_205508.xlsx
    AUT_2019_1991_10042019_205601.xlsx
    AUT_2019_1992_10042019_205654.xlsx
    AUT_2019_1993_10042019_205746.xlsx
    AUT_2019_1994_10042019_205839.xlsx
    ...

/puller_cache/ipcc/xls/BE:
    BEL_2019_1990_12042019_023222.xlsx
    BEL_2019_1991_12042019_023341.xlsx
    BEL_2019_1992_12042019_023458.xlsx
    ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Country:
    &#34;&#34;&#34;
    Represents one country&#39;s dataset and contains many `Year` objects.
    Each `Year` references a single excel file and has a `df` property.

    The final file structure will look like this:

        /puller_cache/ipcc/xls/AT:
            AUT_2019_1990_10042019_205508.xlsx
            AUT_2019_1991_10042019_205601.xlsx
            AUT_2019_1992_10042019_205654.xlsx
            AUT_2019_1993_10042019_205746.xlsx
            AUT_2019_1994_10042019_205839.xlsx
            ...

        /puller_cache/ipcc/xls/BE:
            BEL_2019_1990_12042019_023222.xlsx
            BEL_2019_1991_12042019_023341.xlsx
            BEL_2019_1992_12042019_023458.xlsx
            ...
    &#34;&#34;&#34;

    def __init__(self, iso2_code, xls_cache_dir):
        # The reference ISO2 code #
        self.iso2_code = iso2_code
        # Record where the cache will be located on disk #
        self.cache_dir = xls_cache_dir
        # Main directory #
        self.zip_dir = all_zip_files.cache_dir + self.iso2_code + &#39;/&#39;

    def __repr__(self):
        return &#39;%s object code &#34;%s&#34;&#39; % (self.__class__, self.iso2_code)

    # Convenience shortcut to self.all_years #
    def __getitem__(self, key): return self.all_years[key]
    def __iter__(self):         return iter(self.all_years)
    def __len__(self):          return len(self.all_years)

    # ---------------------------- Properties --------------------------------#
    @property_cached
    def iso3_code(self):
        &#34;&#34;&#34;Get the ISO3 code for this country.&#34;&#34;&#34;
        # Find the right row #
        row = country_codes.loc[country_codes[&#39;iso2_code&#39;] == self.iso2_code].iloc[0]
        # Get the ISO3 #
        return row[&#39;iso3_code&#39;]

    @property_cached
    def zip_files(self):
        &#34;&#34;&#34;Return a list of all zip files present for this country.&#34;&#34;&#34;
        return self.zip_dir.flat_files

    @property_cached
    def zip_file(self):
        &#34;&#34;&#34;
        Return only the single zip that we are interested in for this country.
        If there are several zip files available, we pick the one that matches
        the country&#39;s ISO3 code.
        For instance, in this study, we don&#39;t want to include large areas such
        as greenland when considering Denmark, nor French islands etc.
        &#34;&#34;&#34;
        # Standard case #
        if len(self.zip_files) == 0: return self.zip_files[0]
        # How to parse the ISO3 code from the filename #
        def find_iso3_code(zip_file):
            matches = re.findall(&#34;^([a-z]+)-[0-9]+&#34;, zip_file.name)
            if not matches: return None
            return matches[0]
        # Case with multiple choices #
        for z in self.zip_files:
            if find_iso3_code(z).upper() == self.iso3_code: return z

    @property_cached
    def xls_dir(self):
        &#34;&#34;&#34;Determine where to store all the xls files for this country.&#34;&#34;&#34;
        return self.cache_dir + self.iso2_code + &#39;/&#39;

    @property_cached
    def all_xls_files(self):
        &#34;&#34;&#34;For each country we have N excel files, one for each year.&#34;&#34;&#34;
        # If the xls_dir is empty, we need to reconstruct from cache #
        if self.cache_dir.empty:
            return [self.xls_dir + f.strip(&#39;\n&#39;) for f in self.cached_xls_list]
        # Otherwise we can just look at each file #
        return [f for f in self.xls_dir.flat_files if f.extension == &#39;.xlsx&#39;]

    @property_cached
    def all_years(self):
        &#34;&#34;&#34;Every file holds data for a specific year.&#34;&#34;&#34;
        return [Year(self, xls) for xls in self.all_xls_files]

    @property_cached
    def years(self):
        &#34;&#34;&#34;A dictionary of every year for which we have data.&#34;&#34;&#34;
        return {y.year: y for y in self.all_years}

    # ------------------------------ Convenience ---------------------------------#
    @property
    def first_year(self):
        &#34;&#34;&#34;The earliest year for which we have data.&#34;&#34;&#34;
        return self.all_years[0]

    @property
    def last_year(self):
        &#34;&#34;&#34;The latest year for which we have data.&#34;&#34;&#34;
        return self.all_years[-1]

    # ------------------------------ Methods ---------------------------------#
    def uncompress(self):
        &#34;&#34;&#34;Uncompress the zip file contents to its own directory.&#34;&#34;&#34;
        # Remove and regenerate #
        self.xls_dir.remove()
        self.zip_file.unzip_to(self.xls_dir, single=False)
        # Sometimes randomly the zip contains a directory so we have to unnest #
        all_dirs  = self.xls_dir.flat_directories
        all_files = self.xls_dir.flat_files
        if len(all_dirs) == 1 and len(all_files) == 0:
            nested_dir = all_dirs[0]
            nested_dir.unnest()
        # Return #
        return len(self.xls_dir)

    # ------------------------------- Caching ---------------------------------#
    @property
    def cached_xls_list(self):
        &#34;&#34;&#34;The location where we will save the list of excel files paths.&#34;&#34;&#34;
        return cache_dir + &#39;ipcc/countries/&#39; + self.iso2_code + &#39;.txt&#39;

    def write_xls_list(self):
        &#34;&#34;&#34;
        Create the file that will be used for caching the list of xls files.
        We have to record relative paths starting from self.xls_dir
        &#34;&#34;&#34;
        # Get all paths #
        paths = (f.rel_path_from(self.xls_dir) for f in self.all_xls_files)
        # Write to text file #
        self.cached_xls_list.writelines(line + &#39;\n&#39; for line in paths)
        # Return #
        return self.cached_xls_list</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="forest_puller.ipcc.country.Country.all_xls_files"><code class="name">var <span class="ident">all_xls_files</span></code></dt>
<dd>
<div class="desc"><p>For each country we have N excel files, one for each year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.all_years"><code class="name">var <span class="ident">all_years</span></code></dt>
<dd>
<div class="desc"><p>Every file holds data for a specific year.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.cached_xls_list"><code class="name">var <span class="ident">cached_xls_list</span></code></dt>
<dd>
<div class="desc"><p>The location where we will save the list of excel files paths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cached_xls_list(self):
    &#34;&#34;&#34;The location where we will save the list of excel files paths.&#34;&#34;&#34;
    return cache_dir + &#39;ipcc/countries/&#39; + self.iso2_code + &#39;.txt&#39;</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.first_year"><code class="name">var <span class="ident">first_year</span></code></dt>
<dd>
<div class="desc"><p>The earliest year for which we have data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def first_year(self):
    &#34;&#34;&#34;The earliest year for which we have data.&#34;&#34;&#34;
    return self.all_years[0]</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.iso3_code"><code class="name">var <span class="ident">iso3_code</span></code></dt>
<dd>
<div class="desc"><p>Get the ISO3 code for this country.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.last_year"><code class="name">var <span class="ident">last_year</span></code></dt>
<dd>
<div class="desc"><p>The latest year for which we have data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_year(self):
    &#34;&#34;&#34;The latest year for which we have data.&#34;&#34;&#34;
    return self.all_years[-1]</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.xls_dir"><code class="name">var <span class="ident">xls_dir</span></code></dt>
<dd>
<div class="desc"><p>Determine where to store all the xls files for this country.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.years"><code class="name">var <span class="ident">years</span></code></dt>
<dd>
<div class="desc"><p>A dictionary of every year for which we have data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.zip_file"><code class="name">var <span class="ident">zip_file</span></code></dt>
<dd>
<div class="desc"><p>Return only the single zip that we are interested in for this country.
If there are several zip files available, we pick the one that matches
the country's ISO3 code.
For instance, in this study, we don't want to include large areas such
as greenland when considering Denmark, nor French islands etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.zip_files"><code class="name">var <span class="ident">zip_files</span></code></dt>
<dd>
<div class="desc"><p>Return a list of all zip files present for this country.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="forest_puller.ipcc.country.Country.uncompress"><code class="name flex">
<span>def <span class="ident">uncompress</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uncompress the zip file contents to its own directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uncompress(self):
    &#34;&#34;&#34;Uncompress the zip file contents to its own directory.&#34;&#34;&#34;
    # Remove and regenerate #
    self.xls_dir.remove()
    self.zip_file.unzip_to(self.xls_dir, single=False)
    # Sometimes randomly the zip contains a directory so we have to unnest #
    all_dirs  = self.xls_dir.flat_directories
    all_files = self.xls_dir.flat_files
    if len(all_dirs) == 1 and len(all_files) == 0:
        nested_dir = all_dirs[0]
        nested_dir.unnest()
    # Return #
    return len(self.xls_dir)</code></pre>
</details>
</dd>
<dt id="forest_puller.ipcc.country.Country.write_xls_list"><code class="name flex">
<span>def <span class="ident">write_xls_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the file that will be used for caching the list of xls files.
We have to record relative paths starting from self.xls_dir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_xls_list(self):
    &#34;&#34;&#34;
    Create the file that will be used for caching the list of xls files.
    We have to record relative paths starting from self.xls_dir
    &#34;&#34;&#34;
    # Get all paths #
    paths = (f.rel_path_from(self.xls_dir) for f in self.all_xls_files)
    # Write to text file #
    self.cached_xls_list.writelines(line + &#39;\n&#39; for line in paths)
    # Return #
    return self.cached_xls_list</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="forest_puller.ipcc" href="index.html">forest_puller.ipcc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="forest_puller.ipcc.country.Country" href="#forest_puller.ipcc.country.Country">Country</a></code></h4>
<ul class="two-column">
<li><code><a title="forest_puller.ipcc.country.Country.all_xls_files" href="#forest_puller.ipcc.country.Country.all_xls_files">all_xls_files</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.all_years" href="#forest_puller.ipcc.country.Country.all_years">all_years</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.cached_xls_list" href="#forest_puller.ipcc.country.Country.cached_xls_list">cached_xls_list</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.first_year" href="#forest_puller.ipcc.country.Country.first_year">first_year</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.iso3_code" href="#forest_puller.ipcc.country.Country.iso3_code">iso3_code</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.last_year" href="#forest_puller.ipcc.country.Country.last_year">last_year</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.uncompress" href="#forest_puller.ipcc.country.Country.uncompress">uncompress</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.write_xls_list" href="#forest_puller.ipcc.country.Country.write_xls_list">write_xls_list</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.xls_dir" href="#forest_puller.ipcc.country.Country.xls_dir">xls_dir</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.years" href="#forest_puller.ipcc.country.Country.years">years</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.zip_file" href="#forest_puller.ipcc.country.Country.zip_file">zip_file</a></code></li>
<li><code><a title="forest_puller.ipcc.country.Country.zip_files" href="#forest_puller.ipcc.country.Country.zip_files">zip_files</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>