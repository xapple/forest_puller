<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>forest_puller.soef.composition API documentation</title>
<meta name="description" content="Written by Lucas Sinclair and Paul Rougieux â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>forest_puller.soef.composition</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair and Paul Rougieux.</p>
<p>JRC Biomass Project.
Unit D1 Bioeconomy.</p>
<p>Typically you can use this class like this:</p>
<pre><code>&gt;&gt;&gt; from forest_puller.soef.composition import composition_data
&gt;&gt;&gt; print(composition_data.avg_densities)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair and Paul Rougieux.

JRC Biomass Project.
Unit D1 Bioeconomy.

Typically you can use this class like this:

    &gt;&gt;&gt; from forest_puller.soef.composition import composition_data
    &gt;&gt;&gt; print(composition_data.avg_densities)
&#34;&#34;&#34;

# Built-in modules #

# Internal modules #
from forest_puller import cache_dir

# First party modules #
from plumbing.cache import property_cached, property_pickled

# Third party modules #
import pandas, numpy

###############################################################################
class CompositionData:
    &#34;&#34;&#34;
    Post-processing of the soef &#34;growing_stock&#34; table to compute, for instance,
    the relative proportion of genera, in each country, where available,
    as well as their corresponding wood densities for later conversion between
    volume and mass.
    &#34;&#34;&#34;

    def __init__(self, cache):
        # Where we will pickle all the dataframes #
        self.cache_dir = cache

    #----------------------------- Data sources ------------------------------#
    @property_cached
    def stock_comp(self):
        &#34;&#34;&#34;Load the table with the species breakdown per year per country.&#34;&#34;&#34;
        # Import #
        import forest_puller.soef.concat
        # Load #
        result = forest_puller.soef.concat.tables[&#39;stock_comp&#39;]
        # Return #
        return result

    @property_cached
    def latin_mapping(self):
        &#34;&#34;&#34;Assign a species and genus to each latin name.&#34;&#34;&#34;
        # Load #
        all_latin_names = pandas.Series(self.stock_comp[&#39;latin_name&#39;].unique())
        # Mapping table #
        from forest_puller.conversion.genus_npl import genus_parser
        result = all_latin_names.map(genus_parser)
        # Unzip #
        genus, species = list(zip(*result))
        # Make data frame #
        result = pandas.DataFrame({&#39;latin_name&#39;: all_latin_names,
                                   &#39;genus&#39;:      genus,
                                   &#39;species&#39;:    species})
        # Return #
        return result

    @property_cached
    def stock_density(self):
        &#34;&#34;&#34;Join stock_comp with latin_mapping and density.&#34;&#34;&#34;
        # Import #
        from forest_puller.conversion.tree_species_info import df as species_info
        # Join 1 #
        result = self.stock_comp.left_join(self.latin_mapping, on=&#39;latin_name&#39;)
        # Join 2 #
        result = result.left_join(species_info, on=[&#39;genus&#39;, &#39;species&#39;])
        # Reorder columns #
        cols = [&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;, &#39;genus&#39;, &#39;species&#39;,
                &#39;latin_name&#39;, &#39;growing_stock&#39;, &#39;density&#39;]
        result = result[cols]
        # Sort the dataframe #
        result = result.sort_values(by=[&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;])
        # Return #
        return result

    def collapse(self, subdf):
        &#34;&#34;&#34;
        Function used to compute each extra row (used below).
        Takes a dataframe and returns a dataframe.
        &#34;&#34;&#34;
        # Reset the index #
        subdf = subdf.reset_index(drop=True)
        # Parse the country and year #
        country = subdf.loc[0, &#39;country&#39;]
        year    = subdf.loc[0, &#39;year&#39;]
        # Select all unassigned except total #
        selector    = (subdf[&#39;density&#39;] != subdf[&#39;density&#39;]) &amp; \
                      (subdf[&#39;rank&#39;]    != &#39;total&#39;)
        # Save the unassigned elsewhere #
        unassigned  = subdf[selector].copy()
        # Drop the unassigned in the main dataframe #
        subdf       = subdf[~selector].copy()
        # Sum the unassigned #
        unass_stock = unassigned[&#39;growing_stock&#39;].sum()
        # Add a &#39;remaining&#39; row with the unassigned stock #
        row = pandas.Series({&#39;country&#39;:      country,
                             &#39;year&#39;:         year,
                             &#39;rank&#39;:         &#39;remaining&#39;,
                             &#39;latin_name&#39;:   &#39;remaining&#39;,
                             &#39;species&#39;:      &#39;missing&#39;,
                             &#39;genus&#39;:        &#39;missing&#39;,
                             &#39;growing_stock&#39;: unass_stock,
                             &#39;density&#39;:       numpy.NaN})
        # Can only append a Series if ignore_index=True #
        subdf = subdf.append(row, ignore_index=True)
        # Return #
        return subdf

    @property_cached
    def stock_collapsed(self):
        &#34;&#34;&#34;Collapse the unmatched into remaining.&#34;&#34;&#34;
        # Group #
        groups = self.stock_density.groupby([&#39;country&#39;, &#39;year&#39;])
        # Apply #
        result = groups.apply(self.collapse)
        # Drop index #
        result = result.reset_index(drop=True)
        # Return #
        return result

    def sanity_check(self):
        &#34;&#34;&#34;
        Recompute the total from the composition and see if
        it matches with the original total.
        &#34;&#34;&#34;
        # Totals by country and year -- from their calculation #
        theirs = self.stock_collapsed.query(&#39;rank==&#34;total&#34;&#39;)
        theirs = theirs[[&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;, &#39;growing_stock&#39;]]
        theirs = theirs.reset_index(drop=True)
        # Totals by country and year -- from our calculation #
        groups = self.stock_collapsed.groupby([&#39;country&#39;, &#39;year&#39;])
        # Dataframe to dataframe function #
        def sanity_check_total(subdf):
            # Reset the index #
            subdf = subdf.reset_index(drop=True)
            # Parse the country and year #
            country = subdf.loc[0, &#39;country&#39;]
            year    = subdf.loc[0, &#39;year&#39;]
            # Select all except total #
            selector  = (subdf[&#39;rank&#39;]    != &#39;total&#39;)
            # Save the unassigned elsewhere #
            all_stock = subdf[selector].copy()
            # Sum the unassigned #
            total     = all_stock[&#39;growing_stock&#39;].sum()
            # Add a &#39;remaining&#39; row with the unassigned stock #
            return pandas.Series({&#39;country&#39;:      country,
                                  &#39;year&#39;:         year,
                                  &#39;rank&#39;:         &#39;total&#39;,
                                  &#39;growing_stock&#39;: total})
        # Apply #
        ours = groups.apply(sanity_check_total)
        # Drop index #
        ours = ours.reset_index(drop=True)
        # Compare #
        their_years = theirs[[&#39;country&#39;, &#39;year&#39;]]
        our_years   = ours[[&#39;country&#39;,   &#39;year&#39;]]
        their_years = set(map(tuple, their_years.values.tolist()))
        our_years   = set(map(tuple, our_years.values.tolist()))
        print(their_years ^ our_years)
        # Check #
        their_rows = theirs.iterrows()
        our_rows   = ours.iterrows()
        # Loop #
        for x, y in zip(their_rows, our_rows):
            i = x[0]
            j = y[0]
            row_theirs = x[1]
            row_ours   = y[1]
            assert row_ours[&#39;country&#39;] == row_theirs[&#39;country&#39;]
            assert row_ours[&#39;year&#39;]    == row_theirs[&#39;year&#39;]
            country     = row_ours[&#39;country&#39;]
            year        = row_ours[&#39;year&#39;]
            our_stock   = row_ours[&#39;growing_stock&#39;]
            their_stock = row_theirs[&#39;growing_stock&#39;]
            #if our_stock == 0.0: continue
            if not numpy.allclose(our_stock, their_stock, rtol=0.01):
                print(country, year)
                print(our_stock, their_stock)

    def compute_avg_density(self, subdf):
        &#34;&#34;&#34;
        Function used to compute each row (used below).
        Takes a dataframe and returns a row.
        &#34;&#34;&#34;
        # Reset the index #
        subdf = subdf.reset_index(drop=True)
        # Parse the country and year #
        country = subdf.loc[0, &#39;country&#39;]
        year    = subdf.loc[0, &#39;year&#39;]
        # Parse the remaining and total #
        remaining = subdf.query(&#34;rank==&#39;remaining&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
        total     = subdf.query(&#34;rank==&#39;total&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
        # Discard those with no remaining #
        if remaining == 0.0: return None
        # Select all assigned #
        selector     = (subdf[&#39;density&#39;] == subdf[&#39;density&#39;])
        all_assigned = subdf[selector].copy()
        # Discard those with no assigned #
        if len(all_assigned) == 0: return None
        # Average with weights #
        weights     = all_assigned[&#34;growing_stock&#34;]
        avg_density = numpy.average(all_assigned[&#34;density&#34;], weights=weights)
        # Fraction #
        total_assigned = all_assigned[&#39;growing_stock&#39;].sum()
        frac_missing   = 1.0 - (total_assigned / total)
        # Add a &#39;remaining&#39; row with the unassigned stock #
        row = pandas.Series({&#39;country&#39;:      country,
                             &#39;year&#39;:         year,
                             &#39;avg_density&#39;:  avg_density,
                             &#39;frac_missing&#39;: frac_missing})
        # Return #
        return row

    @property_cached
    def avg_densities(self):
        &#34;&#34;&#34;Add the average density and fraction missing columns.&#34;&#34;&#34;
        # Groups #
        groups = self.stock_collapsed.groupby([&#39;country&#39;, &#39;year&#39;])
        # Apply #
        result = groups.apply(self.compute_avg_density)
        # Drop NaN #
        result = result.dropna()
        # Drop index #
        result = result.reset_index(drop=True)
        # Return #
        return result

    #----------------------------- Interpolation -----------------------------#
    def resample_year(self, subdf, lower=None, upper=None):
        &#34;&#34;&#34;Resample a sub-dataframe on the year column.&#34;&#34;&#34;
        # Computer lower bound #
        if lower is None: lower = int(subdf[&#39;year&#39;].min())
        # Compute upper bound #
        if upper is None: upper = int(subdf[&#39;year&#39;].max())
        # Add rows with NaNs #
        indexed = subdf.set_index([&#39;year&#39;])
        reindex = indexed.reindex(range(lower, upper + 1))
        ixreset = reindex.reset_index()
        # Return #
        return ixreset

    def interpolate_density(self, subdf):
        &#34;&#34;&#34;Interpolate the values of a sub-dataframe on the density column.&#34;&#34;&#34;
        # Process #
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].interpolate(method=&#39;linear&#39;)
        # Return #
        return subdf

    def pad_density(self, subdf):
        &#34;&#34;&#34;Pad the values of a sub-dataframe on the density column.&#34;&#34;&#34;
        # Process #
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;ffill&#39;)
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;bfill&#39;)
        # Return #
        return subdf

    @property_pickled
    def avg_dnsty_intrpld(self):
        &#34;&#34;&#34;
        Take the average densities and calculate missing years
        by interpolation strategy.

        Years available are:   1990, 2000, 2005, 2010.
        We will extend to the: 1980 - 2020 range.

        Years that are found within the known interval, will be interpolated
        with the linear method.

        The edges, or years that are outside the interval for which we have
        data will be interpolated using the pad method (i.e. edges will be
        assumed constant).
        &#34;&#34;&#34;
        # Load #
        result = self.avg_densities
        # Apply first resample #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.resample_year)
        result = result.drop(columns=[&#39;country&#39;])
        result = result.reset_index()
        result = result.drop(columns=[&#39;level_1&#39;])
        # Apply first interpolation #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.interpolate_density)
        # Apply second resample #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.resample_year, lower=1980, upper=2021)
        result = result.drop(columns=[&#39;country&#39;])
        result = result.reset_index()
        result = result.drop(columns=[&#39;level_1&#39;])
        # Apply second interpolation #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.pad_density)
        # Return #
        return result

###############################################################################
# Create a singleton #
cache_path       = cache_dir + &#39;soef/composition/&#39;
composition_data = CompositionData(cache_path)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="forest_puller.soef.composition.CompositionData"><code class="flex name class">
<span>class <span class="ident">CompositionData</span></span>
<span>(</span><span>cache)</span>
</code></dt>
<dd>
<div class="desc"><p>Post-processing of the soef "growing_stock" table to compute, for instance,
the relative proportion of genera, in each country, where available,
as well as their corresponding wood densities for later conversion between
volume and mass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompositionData:
    &#34;&#34;&#34;
    Post-processing of the soef &#34;growing_stock&#34; table to compute, for instance,
    the relative proportion of genera, in each country, where available,
    as well as their corresponding wood densities for later conversion between
    volume and mass.
    &#34;&#34;&#34;

    def __init__(self, cache):
        # Where we will pickle all the dataframes #
        self.cache_dir = cache

    #----------------------------- Data sources ------------------------------#
    @property_cached
    def stock_comp(self):
        &#34;&#34;&#34;Load the table with the species breakdown per year per country.&#34;&#34;&#34;
        # Import #
        import forest_puller.soef.concat
        # Load #
        result = forest_puller.soef.concat.tables[&#39;stock_comp&#39;]
        # Return #
        return result

    @property_cached
    def latin_mapping(self):
        &#34;&#34;&#34;Assign a species and genus to each latin name.&#34;&#34;&#34;
        # Load #
        all_latin_names = pandas.Series(self.stock_comp[&#39;latin_name&#39;].unique())
        # Mapping table #
        from forest_puller.conversion.genus_npl import genus_parser
        result = all_latin_names.map(genus_parser)
        # Unzip #
        genus, species = list(zip(*result))
        # Make data frame #
        result = pandas.DataFrame({&#39;latin_name&#39;: all_latin_names,
                                   &#39;genus&#39;:      genus,
                                   &#39;species&#39;:    species})
        # Return #
        return result

    @property_cached
    def stock_density(self):
        &#34;&#34;&#34;Join stock_comp with latin_mapping and density.&#34;&#34;&#34;
        # Import #
        from forest_puller.conversion.tree_species_info import df as species_info
        # Join 1 #
        result = self.stock_comp.left_join(self.latin_mapping, on=&#39;latin_name&#39;)
        # Join 2 #
        result = result.left_join(species_info, on=[&#39;genus&#39;, &#39;species&#39;])
        # Reorder columns #
        cols = [&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;, &#39;genus&#39;, &#39;species&#39;,
                &#39;latin_name&#39;, &#39;growing_stock&#39;, &#39;density&#39;]
        result = result[cols]
        # Sort the dataframe #
        result = result.sort_values(by=[&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;])
        # Return #
        return result

    def collapse(self, subdf):
        &#34;&#34;&#34;
        Function used to compute each extra row (used below).
        Takes a dataframe and returns a dataframe.
        &#34;&#34;&#34;
        # Reset the index #
        subdf = subdf.reset_index(drop=True)
        # Parse the country and year #
        country = subdf.loc[0, &#39;country&#39;]
        year    = subdf.loc[0, &#39;year&#39;]
        # Select all unassigned except total #
        selector    = (subdf[&#39;density&#39;] != subdf[&#39;density&#39;]) &amp; \
                      (subdf[&#39;rank&#39;]    != &#39;total&#39;)
        # Save the unassigned elsewhere #
        unassigned  = subdf[selector].copy()
        # Drop the unassigned in the main dataframe #
        subdf       = subdf[~selector].copy()
        # Sum the unassigned #
        unass_stock = unassigned[&#39;growing_stock&#39;].sum()
        # Add a &#39;remaining&#39; row with the unassigned stock #
        row = pandas.Series({&#39;country&#39;:      country,
                             &#39;year&#39;:         year,
                             &#39;rank&#39;:         &#39;remaining&#39;,
                             &#39;latin_name&#39;:   &#39;remaining&#39;,
                             &#39;species&#39;:      &#39;missing&#39;,
                             &#39;genus&#39;:        &#39;missing&#39;,
                             &#39;growing_stock&#39;: unass_stock,
                             &#39;density&#39;:       numpy.NaN})
        # Can only append a Series if ignore_index=True #
        subdf = subdf.append(row, ignore_index=True)
        # Return #
        return subdf

    @property_cached
    def stock_collapsed(self):
        &#34;&#34;&#34;Collapse the unmatched into remaining.&#34;&#34;&#34;
        # Group #
        groups = self.stock_density.groupby([&#39;country&#39;, &#39;year&#39;])
        # Apply #
        result = groups.apply(self.collapse)
        # Drop index #
        result = result.reset_index(drop=True)
        # Return #
        return result

    def sanity_check(self):
        &#34;&#34;&#34;
        Recompute the total from the composition and see if
        it matches with the original total.
        &#34;&#34;&#34;
        # Totals by country and year -- from their calculation #
        theirs = self.stock_collapsed.query(&#39;rank==&#34;total&#34;&#39;)
        theirs = theirs[[&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;, &#39;growing_stock&#39;]]
        theirs = theirs.reset_index(drop=True)
        # Totals by country and year -- from our calculation #
        groups = self.stock_collapsed.groupby([&#39;country&#39;, &#39;year&#39;])
        # Dataframe to dataframe function #
        def sanity_check_total(subdf):
            # Reset the index #
            subdf = subdf.reset_index(drop=True)
            # Parse the country and year #
            country = subdf.loc[0, &#39;country&#39;]
            year    = subdf.loc[0, &#39;year&#39;]
            # Select all except total #
            selector  = (subdf[&#39;rank&#39;]    != &#39;total&#39;)
            # Save the unassigned elsewhere #
            all_stock = subdf[selector].copy()
            # Sum the unassigned #
            total     = all_stock[&#39;growing_stock&#39;].sum()
            # Add a &#39;remaining&#39; row with the unassigned stock #
            return pandas.Series({&#39;country&#39;:      country,
                                  &#39;year&#39;:         year,
                                  &#39;rank&#39;:         &#39;total&#39;,
                                  &#39;growing_stock&#39;: total})
        # Apply #
        ours = groups.apply(sanity_check_total)
        # Drop index #
        ours = ours.reset_index(drop=True)
        # Compare #
        their_years = theirs[[&#39;country&#39;, &#39;year&#39;]]
        our_years   = ours[[&#39;country&#39;,   &#39;year&#39;]]
        their_years = set(map(tuple, their_years.values.tolist()))
        our_years   = set(map(tuple, our_years.values.tolist()))
        print(their_years ^ our_years)
        # Check #
        their_rows = theirs.iterrows()
        our_rows   = ours.iterrows()
        # Loop #
        for x, y in zip(their_rows, our_rows):
            i = x[0]
            j = y[0]
            row_theirs = x[1]
            row_ours   = y[1]
            assert row_ours[&#39;country&#39;] == row_theirs[&#39;country&#39;]
            assert row_ours[&#39;year&#39;]    == row_theirs[&#39;year&#39;]
            country     = row_ours[&#39;country&#39;]
            year        = row_ours[&#39;year&#39;]
            our_stock   = row_ours[&#39;growing_stock&#39;]
            their_stock = row_theirs[&#39;growing_stock&#39;]
            #if our_stock == 0.0: continue
            if not numpy.allclose(our_stock, their_stock, rtol=0.01):
                print(country, year)
                print(our_stock, their_stock)

    def compute_avg_density(self, subdf):
        &#34;&#34;&#34;
        Function used to compute each row (used below).
        Takes a dataframe and returns a row.
        &#34;&#34;&#34;
        # Reset the index #
        subdf = subdf.reset_index(drop=True)
        # Parse the country and year #
        country = subdf.loc[0, &#39;country&#39;]
        year    = subdf.loc[0, &#39;year&#39;]
        # Parse the remaining and total #
        remaining = subdf.query(&#34;rank==&#39;remaining&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
        total     = subdf.query(&#34;rank==&#39;total&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
        # Discard those with no remaining #
        if remaining == 0.0: return None
        # Select all assigned #
        selector     = (subdf[&#39;density&#39;] == subdf[&#39;density&#39;])
        all_assigned = subdf[selector].copy()
        # Discard those with no assigned #
        if len(all_assigned) == 0: return None
        # Average with weights #
        weights     = all_assigned[&#34;growing_stock&#34;]
        avg_density = numpy.average(all_assigned[&#34;density&#34;], weights=weights)
        # Fraction #
        total_assigned = all_assigned[&#39;growing_stock&#39;].sum()
        frac_missing   = 1.0 - (total_assigned / total)
        # Add a &#39;remaining&#39; row with the unassigned stock #
        row = pandas.Series({&#39;country&#39;:      country,
                             &#39;year&#39;:         year,
                             &#39;avg_density&#39;:  avg_density,
                             &#39;frac_missing&#39;: frac_missing})
        # Return #
        return row

    @property_cached
    def avg_densities(self):
        &#34;&#34;&#34;Add the average density and fraction missing columns.&#34;&#34;&#34;
        # Groups #
        groups = self.stock_collapsed.groupby([&#39;country&#39;, &#39;year&#39;])
        # Apply #
        result = groups.apply(self.compute_avg_density)
        # Drop NaN #
        result = result.dropna()
        # Drop index #
        result = result.reset_index(drop=True)
        # Return #
        return result

    #----------------------------- Interpolation -----------------------------#
    def resample_year(self, subdf, lower=None, upper=None):
        &#34;&#34;&#34;Resample a sub-dataframe on the year column.&#34;&#34;&#34;
        # Computer lower bound #
        if lower is None: lower = int(subdf[&#39;year&#39;].min())
        # Compute upper bound #
        if upper is None: upper = int(subdf[&#39;year&#39;].max())
        # Add rows with NaNs #
        indexed = subdf.set_index([&#39;year&#39;])
        reindex = indexed.reindex(range(lower, upper + 1))
        ixreset = reindex.reset_index()
        # Return #
        return ixreset

    def interpolate_density(self, subdf):
        &#34;&#34;&#34;Interpolate the values of a sub-dataframe on the density column.&#34;&#34;&#34;
        # Process #
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].interpolate(method=&#39;linear&#39;)
        # Return #
        return subdf

    def pad_density(self, subdf):
        &#34;&#34;&#34;Pad the values of a sub-dataframe on the density column.&#34;&#34;&#34;
        # Process #
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;ffill&#39;)
        subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;bfill&#39;)
        # Return #
        return subdf

    @property_pickled
    def avg_dnsty_intrpld(self):
        &#34;&#34;&#34;
        Take the average densities and calculate missing years
        by interpolation strategy.

        Years available are:   1990, 2000, 2005, 2010.
        We will extend to the: 1980 - 2020 range.

        Years that are found within the known interval, will be interpolated
        with the linear method.

        The edges, or years that are outside the interval for which we have
        data will be interpolated using the pad method (i.e. edges will be
        assumed constant).
        &#34;&#34;&#34;
        # Load #
        result = self.avg_densities
        # Apply first resample #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.resample_year)
        result = result.drop(columns=[&#39;country&#39;])
        result = result.reset_index()
        result = result.drop(columns=[&#39;level_1&#39;])
        # Apply first interpolation #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.interpolate_density)
        # Apply second resample #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.resample_year, lower=1980, upper=2021)
        result = result.drop(columns=[&#39;country&#39;])
        result = result.reset_index()
        result = result.drop(columns=[&#39;level_1&#39;])
        # Apply second interpolation #
        groups = result.groupby([&#39;country&#39;])
        result = groups.apply(self.pad_density)
        # Return #
        return result</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="forest_puller.soef.composition.CompositionData.avg_densities"><code class="name">var <span class="ident">avg_densities</span></code></dt>
<dd>
<div class="desc"><p>Add the average density and fraction missing columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.avg_dnsty_intrpld"><code class="name">var <span class="ident">avg_dnsty_intrpld</span></code></dt>
<dd>
<div class="desc"><p>Take the average densities and calculate missing years
by interpolation strategy.</p>
<p>Years available are:
1990, 2000, 2005, 2010.
We will extend to the: 1980 - 2020 range.</p>
<p>Years that are found within the known interval, will be interpolated
with the linear method.</p>
<p>The edges, or years that are outside the interval for which we have
data will be interpolated using the pad method (i.e. edges will be
assumed constant).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see this docstring or code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # Where should we look in the file system ? #
    path = self.get_pickle_path(instance)
    # Is the answer already on the file system? #
    if path.exists:
        with open(path, &#39;rb&#39;) as handle: result = pickle.load(handle)
        instance.__cache__[self.name] = result
        return result
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later in the cache #
    instance.__cache__[self.name] = result
    # And also store it on the disk #
    with open(path, &#39;wb&#39;) as handle: pickle.dump(result, handle)
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.latin_mapping"><code class="name">var <span class="ident">latin_mapping</span></code></dt>
<dd>
<div class="desc"><p>Assign a species and genus to each latin name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.stock_collapsed"><code class="name">var <span class="ident">stock_collapsed</span></code></dt>
<dd>
<div class="desc"><p>Collapse the unmatched into remaining.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.stock_comp"><code class="name">var <span class="ident">stock_comp</span></code></dt>
<dd>
<div class="desc"><p>Load the table with the species breakdown per year per country.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.stock_density"><code class="name">var <span class="ident">stock_density</span></code></dt>
<dd>
<div class="desc"><p>Join stock_comp with latin_mapping and density.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner):
    &#34;&#34;&#34;
    If you see the current source code in a seemingly unrelated part of
    an auto-generated documentation, it means the program making the
    documentation was unable to correctly traverse a decorated property.
    &#34;&#34;&#34;
    # For debugging purposes #
    if False: print(&#34;-&gt; property cached `%s`&#34; % instance)
    # If called from a class #
    if instance is None: return self
    # Does a cache exist for this instance? #
    self.check_cache(instance)
    # Is the answer in the cache? #
    if self.name in instance.__cache__: return instance.__cache__[self.name]
    # If not we will compute it #
    if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
    else:                                      result = self.func(instance)
    # Let&#39;s store the answer for later #
    instance.__cache__[self.name] = result
    # Return #
    return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="forest_puller.soef.composition.CompositionData.collapse"><code class="name flex">
<span>def <span class="ident">collapse</span></span>(<span>self, subdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to compute each extra row (used below).
Takes a dataframe and returns a dataframe.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapse(self, subdf):
    &#34;&#34;&#34;
    Function used to compute each extra row (used below).
    Takes a dataframe and returns a dataframe.
    &#34;&#34;&#34;
    # Reset the index #
    subdf = subdf.reset_index(drop=True)
    # Parse the country and year #
    country = subdf.loc[0, &#39;country&#39;]
    year    = subdf.loc[0, &#39;year&#39;]
    # Select all unassigned except total #
    selector    = (subdf[&#39;density&#39;] != subdf[&#39;density&#39;]) &amp; \
                  (subdf[&#39;rank&#39;]    != &#39;total&#39;)
    # Save the unassigned elsewhere #
    unassigned  = subdf[selector].copy()
    # Drop the unassigned in the main dataframe #
    subdf       = subdf[~selector].copy()
    # Sum the unassigned #
    unass_stock = unassigned[&#39;growing_stock&#39;].sum()
    # Add a &#39;remaining&#39; row with the unassigned stock #
    row = pandas.Series({&#39;country&#39;:      country,
                         &#39;year&#39;:         year,
                         &#39;rank&#39;:         &#39;remaining&#39;,
                         &#39;latin_name&#39;:   &#39;remaining&#39;,
                         &#39;species&#39;:      &#39;missing&#39;,
                         &#39;genus&#39;:        &#39;missing&#39;,
                         &#39;growing_stock&#39;: unass_stock,
                         &#39;density&#39;:       numpy.NaN})
    # Can only append a Series if ignore_index=True #
    subdf = subdf.append(row, ignore_index=True)
    # Return #
    return subdf</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.compute_avg_density"><code class="name flex">
<span>def <span class="ident">compute_avg_density</span></span>(<span>self, subdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to compute each row (used below).
Takes a dataframe and returns a row.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_avg_density(self, subdf):
    &#34;&#34;&#34;
    Function used to compute each row (used below).
    Takes a dataframe and returns a row.
    &#34;&#34;&#34;
    # Reset the index #
    subdf = subdf.reset_index(drop=True)
    # Parse the country and year #
    country = subdf.loc[0, &#39;country&#39;]
    year    = subdf.loc[0, &#39;year&#39;]
    # Parse the remaining and total #
    remaining = subdf.query(&#34;rank==&#39;remaining&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
    total     = subdf.query(&#34;rank==&#39;total&#39;&#34;)[&#39;growing_stock&#39;].iloc[0]
    # Discard those with no remaining #
    if remaining == 0.0: return None
    # Select all assigned #
    selector     = (subdf[&#39;density&#39;] == subdf[&#39;density&#39;])
    all_assigned = subdf[selector].copy()
    # Discard those with no assigned #
    if len(all_assigned) == 0: return None
    # Average with weights #
    weights     = all_assigned[&#34;growing_stock&#34;]
    avg_density = numpy.average(all_assigned[&#34;density&#34;], weights=weights)
    # Fraction #
    total_assigned = all_assigned[&#39;growing_stock&#39;].sum()
    frac_missing   = 1.0 - (total_assigned / total)
    # Add a &#39;remaining&#39; row with the unassigned stock #
    row = pandas.Series({&#39;country&#39;:      country,
                         &#39;year&#39;:         year,
                         &#39;avg_density&#39;:  avg_density,
                         &#39;frac_missing&#39;: frac_missing})
    # Return #
    return row</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.interpolate_density"><code class="name flex">
<span>def <span class="ident">interpolate_density</span></span>(<span>self, subdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate the values of a sub-dataframe on the density column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_density(self, subdf):
    &#34;&#34;&#34;Interpolate the values of a sub-dataframe on the density column.&#34;&#34;&#34;
    # Process #
    subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].interpolate(method=&#39;linear&#39;)
    # Return #
    return subdf</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.pad_density"><code class="name flex">
<span>def <span class="ident">pad_density</span></span>(<span>self, subdf)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad the values of a sub-dataframe on the density column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_density(self, subdf):
    &#34;&#34;&#34;Pad the values of a sub-dataframe on the density column.&#34;&#34;&#34;
    # Process #
    subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;ffill&#39;)
    subdf[&#39;avg_density&#39;] = subdf[&#39;avg_density&#39;].fillna(method=&#39;bfill&#39;)
    # Return #
    return subdf</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.resample_year"><code class="name flex">
<span>def <span class="ident">resample_year</span></span>(<span>self, subdf, lower=None, upper=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resample a sub-dataframe on the year column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample_year(self, subdf, lower=None, upper=None):
    &#34;&#34;&#34;Resample a sub-dataframe on the year column.&#34;&#34;&#34;
    # Computer lower bound #
    if lower is None: lower = int(subdf[&#39;year&#39;].min())
    # Compute upper bound #
    if upper is None: upper = int(subdf[&#39;year&#39;].max())
    # Add rows with NaNs #
    indexed = subdf.set_index([&#39;year&#39;])
    reindex = indexed.reindex(range(lower, upper + 1))
    ixreset = reindex.reset_index()
    # Return #
    return ixreset</code></pre>
</details>
</dd>
<dt id="forest_puller.soef.composition.CompositionData.sanity_check"><code class="name flex">
<span>def <span class="ident">sanity_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Recompute the total from the composition and see if
it matches with the original total.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sanity_check(self):
    &#34;&#34;&#34;
    Recompute the total from the composition and see if
    it matches with the original total.
    &#34;&#34;&#34;
    # Totals by country and year -- from their calculation #
    theirs = self.stock_collapsed.query(&#39;rank==&#34;total&#34;&#39;)
    theirs = theirs[[&#39;country&#39;, &#39;year&#39;, &#39;rank&#39;, &#39;growing_stock&#39;]]
    theirs = theirs.reset_index(drop=True)
    # Totals by country and year -- from our calculation #
    groups = self.stock_collapsed.groupby([&#39;country&#39;, &#39;year&#39;])
    # Dataframe to dataframe function #
    def sanity_check_total(subdf):
        # Reset the index #
        subdf = subdf.reset_index(drop=True)
        # Parse the country and year #
        country = subdf.loc[0, &#39;country&#39;]
        year    = subdf.loc[0, &#39;year&#39;]
        # Select all except total #
        selector  = (subdf[&#39;rank&#39;]    != &#39;total&#39;)
        # Save the unassigned elsewhere #
        all_stock = subdf[selector].copy()
        # Sum the unassigned #
        total     = all_stock[&#39;growing_stock&#39;].sum()
        # Add a &#39;remaining&#39; row with the unassigned stock #
        return pandas.Series({&#39;country&#39;:      country,
                              &#39;year&#39;:         year,
                              &#39;rank&#39;:         &#39;total&#39;,
                              &#39;growing_stock&#39;: total})
    # Apply #
    ours = groups.apply(sanity_check_total)
    # Drop index #
    ours = ours.reset_index(drop=True)
    # Compare #
    their_years = theirs[[&#39;country&#39;, &#39;year&#39;]]
    our_years   = ours[[&#39;country&#39;,   &#39;year&#39;]]
    their_years = set(map(tuple, their_years.values.tolist()))
    our_years   = set(map(tuple, our_years.values.tolist()))
    print(their_years ^ our_years)
    # Check #
    their_rows = theirs.iterrows()
    our_rows   = ours.iterrows()
    # Loop #
    for x, y in zip(their_rows, our_rows):
        i = x[0]
        j = y[0]
        row_theirs = x[1]
        row_ours   = y[1]
        assert row_ours[&#39;country&#39;] == row_theirs[&#39;country&#39;]
        assert row_ours[&#39;year&#39;]    == row_theirs[&#39;year&#39;]
        country     = row_ours[&#39;country&#39;]
        year        = row_ours[&#39;year&#39;]
        our_stock   = row_ours[&#39;growing_stock&#39;]
        their_stock = row_theirs[&#39;growing_stock&#39;]
        #if our_stock == 0.0: continue
        if not numpy.allclose(our_stock, their_stock, rtol=0.01):
            print(country, year)
            print(our_stock, their_stock)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="forest_puller.soef" href="index.html">forest_puller.soef</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="forest_puller.soef.composition.CompositionData" href="#forest_puller.soef.composition.CompositionData">CompositionData</a></code></h4>
<ul class="two-column">
<li><code><a title="forest_puller.soef.composition.CompositionData.avg_densities" href="#forest_puller.soef.composition.CompositionData.avg_densities">avg_densities</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.avg_dnsty_intrpld" href="#forest_puller.soef.composition.CompositionData.avg_dnsty_intrpld">avg_dnsty_intrpld</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.collapse" href="#forest_puller.soef.composition.CompositionData.collapse">collapse</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.compute_avg_density" href="#forest_puller.soef.composition.CompositionData.compute_avg_density">compute_avg_density</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.interpolate_density" href="#forest_puller.soef.composition.CompositionData.interpolate_density">interpolate_density</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.latin_mapping" href="#forest_puller.soef.composition.CompositionData.latin_mapping">latin_mapping</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.pad_density" href="#forest_puller.soef.composition.CompositionData.pad_density">pad_density</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.resample_year" href="#forest_puller.soef.composition.CompositionData.resample_year">resample_year</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.sanity_check" href="#forest_puller.soef.composition.CompositionData.sanity_check">sanity_check</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.stock_collapsed" href="#forest_puller.soef.composition.CompositionData.stock_collapsed">stock_collapsed</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.stock_comp" href="#forest_puller.soef.composition.CompositionData.stock_comp">stock_comp</a></code></li>
<li><code><a title="forest_puller.soef.composition.CompositionData.stock_density" href="#forest_puller.soef.composition.CompositionData.stock_density">stock_density</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>